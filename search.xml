<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[快乐的BUU刷题之旅-Crypto]]></title>
    <url>%2F2020%2F01%2F11%2F%E5%BF%AB%E4%B9%90%E7%9A%84BUU%E5%88%B7%E9%A2%98%E4%B9%8B%E6%97%85-Crypto%2F</url>
    <content type="text"><![CDATA[快乐的BUU刷题之旅开始了，持续更新中!能自己写的脚本就自己写了，顺便练练python，写得不好的地方，请大家见谅。 MD5题目描述：e00cf25ad42683b3df678c61f42c6bda工具：https://www.cmd5.com/解法及思路：0.直接cmd5跑一下1.flag{admin1} 看我回旋踢题目描述：synt{5pq1004q-86n5-46q8-o720-oro5on0417r1}工具：https://www.cmd5.com/解法及思路：0.根据题目提示和经验就知道是rot131.脚本： import string upperletters=string.ascii_uppercase lowerletters=string.ascii_lowercase upperdict={} lowerdict={} c=&quot;synt{5pq1004q-86n5-46q8-o720-oro5on0417r1}&quot; m=[] for i in range(0,len(lowerletters)): if i&lt;13: lowerdict[lowerletters[i]]=lowerletters[i+13] else: lowerdict[lowerletters[i]]=lowerletters[i-13] for i in range(0,len(upperletters)): if i&lt;13: upperdict[upperletters[i]]=upperletters[i+13] else: upperdict[upperletters[i]]=upperletters[i-13] for ch in c: if ch in lowerdict: m.append(lowerdict[ch]) elif ch in upperdict: m.append(upperdict[ch]) else: m.append(ch) m=&apos;&apos;.join(m) print(m)2.flag{5cd1004d-86a5-46d8-b720-beb5ba0417e1}]]></content>
      <categories>
        <category>CTF--WP-Crypto</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[改过自新 重新做人！]]></title>
    <url>%2F2020%2F01%2F11%2F%E6%94%B9%E8%BF%87%E8%87%AA%E6%96%B0-%E9%87%8D%E6%96%B0%E5%81%9A%E4%BA%BA%EF%BC%81%2F</url>
    <content type="text"><![CDATA[之前一直说要及时更新博客，但是因为各种事情加上自己的懒惰所以一直没能实现，现在正逢新的一年，所以我决定从现在开始改过自新，重新做人，争取日更！]]></content>
  </entry>
  <entry>
    <title><![CDATA[RSA-低加密指数广播攻击]]></title>
    <url>%2F2019%2F10%2F16%2FRSA-%E4%BD%8E%E5%8A%A0%E5%AF%86%E6%8C%87%E6%95%B0%E5%B9%BF%E6%92%AD%E6%94%BB%E5%87%BB%2F</url>
    <content type="text"><![CDATA[记录一下做题遇到的针对RSA的低加密指数广播攻击 前言在RSA中e也称为加密指数,加密过程中e的选取是可以随机任意的。RSA涉及的都是非常长整数的指数运算，计算过程十分复杂，耗时长，因此自从RSA诞生开始，人们就一直在研究RSA加速技术，现阶段两种最主流的常用加速技术为：1.使用短公开指数的快速加密。2.使用中国余数定理的快速加密。但是使用短公开指数的快速加密，e若是选取不当就会造成安全问题。（此处的安全性和d以及n的位长度仍有关系，短公开指数的快速加密不一定就是不安全的） 低加密指数广播攻击原理和低加密指数攻击相同，如果选取的加密指数较低，并且使用了相同的加密指数给一个接受者的群发送相同的信息，那么可以进行广播攻击得到明文。即，选取了相同的加密指数e（这里取e=3），对相同的明文m进行了加密并进行了消息的传递，那么有：对上述等式运用中国剩余定理，在e=3时，可以得到：通过对密文进行三次开方可以求得明文。 标志这个识别起来比较简单，一般来说都是给了三组加密的参数和明密文，其中题目很明确地能告诉你这三组的明文都是一样的，并且e都取了一个较小的数字。或者是给了多组RSA的加密信息和公钥，并且e都是同一个比较小的数字，并且所有的n都是互质的。 例题[{“c”: 7366067574741171461722065133242916080495505913663250330082747465383676893970411476550748394841437418105312353971095003424322679616940371123028982189502042, “e”: 10, “n”: 25162507052339714421839688873734596177751124036723831003300959761137811490715205742941738406548150240861779301784133652165908227917415483137585388986274803},{“c”: 21962825323300469151795920289886886562790942771546858500842179806566435767103803978885148772139305484319688249368999503784441507383476095946258011317951461, “e”: 10, “n”: 23976859589904419798320812097681858652325473791891232710431997202897819580634937070900625213218095330766877190212418023297341732808839488308551126409983193},{“c”: 6569689420274066957835983390583585286570087619048110141187700584193792695235405077811544355169290382357149374107076406086154103351897890793598997687053983, “e”: 10, “n”: 18503782836858540043974558035601654610948915505645219820150251062305120148745545906567548650191832090823482852604346478335353784501076761922605361848703623},{“c”: 4508246168044513518452493882713536390636741541551805821790338973797615971271867248584379813114125478195284692695928668946553625483179633266057122967547052, “e”: 10, “n”: 23383087478545512218713157932934746110721706819077423418060220083657713428503582801909807142802647367994289775015595100541168367083097506193809451365010723},{“c”: 22966105670291282335588843018244161552764486373117942865966904076191122337435542553276743938817686729554714315494818922753880198945897222422137268427611672, “e”: 10, “n”: 31775649089861428671057909076144152870796722528112580479442073365053916012507273433028451755436987054722496057749731758475958301164082755003195632005308493},{“c”: 17963313063405045742968136916219838352135561785389534381262979264585397896844470879023686508540355160998533122970239261072020689217153126649390825646712087, “e”: 10, “n”: 22246342022943432820696190444155665289928378653841172632283227888174495402248633061010615572642126584591103750338919213945646074833823905521643025879053949},{“c”: 1652417534709029450380570653973705320986117679597563873022683140800507482560482948310131540948227797045505390333146191586749269249548168247316404074014639, “e”: 10, “n”: 25395461142670631268156106136028325744393358436617528677967249347353524924655001151849544022201772500033280822372661344352607434738696051779095736547813043},{“c”: 15585771734488351039456631394040497759568679429510619219766191780807675361741859290490732451112648776648126779759368428205194684721516497026290981786239352, “e”: 10, “n”: 32056508892744184901289413287728039891303832311548608141088227876326753674154124775132776928481935378184756756785107540781632570295330486738268173167809047},{“c”: 8965123421637694050044216844523379163347478029124815032832813225050732558524239660648746284884140746788823681886010577342254841014594570067467905682359797, “e”: 10, “n”: 52849766269541827474228189428820648574162539595985395992261649809907435742263020551050064268890333392877173572811691599841253150460219986817964461970736553},{“c”: 13560945756543023008529388108446940847137853038437095244573035888531288577370829065666320069397898394848484847030321018915638381833935580958342719988978247, “e”: 10, “n”: 30415984800307578932946399987559088968355638354344823359397204419191241802721772499486615661699080998502439901585573950889047918537906687840725005496238621}] 脚本import libnum import gmpy2 dic = [{&quot;c&quot;: 7366067574741171461722065133242916080495505913663250330082747465383676893970411476550748394841437418105312353971095003424322679616940371123028982189502042, &quot;e&quot;: 10, &quot;n&quot;: 25162507052339714421839688873734596177751124036723831003300959761137811490715205742941738406548150240861779301784133652165908227917415483137585388986274803}, {&quot;c&quot;: 21962825323300469151795920289886886562790942771546858500842179806566435767103803978885148772139305484319688249368999503784441507383476095946258011317951461, &quot;e&quot;: 10, &quot;n&quot;: 23976859589904419798320812097681858652325473791891232710431997202897819580634937070900625213218095330766877190212418023297341732808839488308551126409983193}, {&quot;c&quot;: 6569689420274066957835983390583585286570087619048110141187700584193792695235405077811544355169290382357149374107076406086154103351897890793598997687053983, &quot;e&quot;: 10, &quot;n&quot;: 18503782836858540043974558035601654610948915505645219820150251062305120148745545906567548650191832090823482852604346478335353784501076761922605361848703623}, {&quot;c&quot;: 4508246168044513518452493882713536390636741541551805821790338973797615971271867248584379813114125478195284692695928668946553625483179633266057122967547052, &quot;e&quot;: 10, &quot;n&quot;: 23383087478545512218713157932934746110721706819077423418060220083657713428503582801909807142802647367994289775015595100541168367083097506193809451365010723}, {&quot;c&quot;: 22966105670291282335588843018244161552764486373117942865966904076191122337435542553276743938817686729554714315494818922753880198945897222422137268427611672, &quot;e&quot;: 10, &quot;n&quot;: 31775649089861428671057909076144152870796722528112580479442073365053916012507273433028451755436987054722496057749731758475958301164082755003195632005308493}, {&quot;c&quot;: 17963313063405045742968136916219838352135561785389534381262979264585397896844470879023686508540355160998533122970239261072020689217153126649390825646712087, &quot;e&quot;: 10, &quot;n&quot;: 22246342022943432820696190444155665289928378653841172632283227888174495402248633061010615572642126584591103750338919213945646074833823905521643025879053949}, {&quot;c&quot;: 1652417534709029450380570653973705320986117679597563873022683140800507482560482948310131540948227797045505390333146191586749269249548168247316404074014639, &quot;e&quot;: 10, &quot;n&quot;: 25395461142670631268156106136028325744393358436617528677967249347353524924655001151849544022201772500033280822372661344352607434738696051779095736547813043}, {&quot;c&quot;: 15585771734488351039456631394040497759568679429510619219766191780807675361741859290490732451112648776648126779759368428205194684721516497026290981786239352, &quot;e&quot;: 10, &quot;n&quot;: 32056508892744184901289413287728039891303832311548608141088227876326753674154124775132776928481935378184756756785107540781632570295330486738268173167809047}, {&quot;c&quot;: 8965123421637694050044216844523379163347478029124815032832813225050732558524239660648746284884140746788823681886010577342254841014594570067467905682359797, &quot;e&quot;: 10, &quot;n&quot;: 52849766269541827474228189428820648574162539595985395992261649809907435742263020551050064268890333392877173572811691599841253150460219986817964461970736553}, {&quot;c&quot;: 13560945756543023008529388108446940847137853038437095244573035888531288577370829065666320069397898394848484847030321018915638381833935580958342719988978247, &quot;e&quot;: 10, &quot;n&quot;: 30415984800307578932946399987559088968355638354344823359397204419191241802721772499486615661699080998502439901585573950889047918537906687840725005496238621}] n = [] C = [] for i in dic: n.append(i[&quot;n&quot;]) C.append(i[&quot;c&quot;]) N = 1 for i in n: N *= i Ni = [] for i in n: Ni.append(N / i) T = [] for i in xrange(10): T.append(long(gmpy2.invert(Ni[i], n[i]))) X = 0 for i in xrange(10): X += C[i] * Ni[i] * T[i] m10 = X % N m = gmpy2.iroot(m10, 10) print libnum.n2s(m[0])]]></content>
      <categories>
        <category>RSA</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[1-Acid burn]]></title>
    <url>%2F2019%2F08%2F28%2F1-Acid-burn%2F</url>
    <content type="text"><![CDATA[160个Crackme-1 工具：PEID,OD 解法及思路：0.先用PEID差壳，发现无壳，Delphi编写 1.运行程序并随便输入假码观察提示字符串这个NAG得去除（hello you have to kill me!） 2.用OD打开先解决NAG运行程序出现弹窗后再OD暂停按上边K快捷键 在系统领空的 ?user32 MessageBoxExA 右键显式调用下断 重载程序 运行F8单步向下跳出Call 到程序领空向上查找到段首发现没有跳转可以跳过，继续F8单步向下找到关键跳用jmp爆破修改完毕后我们右键-复制到可执行文件-所有修改，选择全部复制，然后跳到D窗口，右键-保存文件。 3.爆破的方法解决Serial和Name/Serial搜索字符串进入查看并修改Serial：Name/Serial： 4.看算法找真码的方法解决SerialSerial：找到关键跳下断，运行程序输入假码发现假码，发现用于比较的关键Call，发现真码Hello Dude! 0018F8F4 01E0A4E0 ASCII &quot;Hello Dude!&quot; 5.观察算法并编写注册机Name/Serial：同样是找到两处关键跳第一处：此处的作用是判断name的长度是否大于或者等于4，将上一个call函数的结果eax跟数字4进行比对，如果小于4则不跳转，执行弹窗函数提示错误；如果大于或等于4则跳转向下执行。第二处：首先对不同Name生成不同Serial进行观察Name:11111Serial: CW-4018-CRACKEDName:11110Serial: CW-4018-CRACKEDName:22222Serial: CW-4100-CRACKED由此不难猜出Name对应的Serial是通过拼接而成的，只用计算出中间的值即可知道Name对应的Serial。取第一个字符，用其ASCII值乘以地址0x431750的值(0x431750在数据区Crtl+G一下找到) 之后乘2，就得出那一串数字。 代码： 0042FA8A |. 0FB600 movzx eax,byte ptr ds:[eax] ; 取出name字符串中的第一个字符 0042FA8D |. F72D 50174300 imul dword ptr ds:[0x431750] ; 乘以0x29(地址431750) 0042FA93 |. A3 50174300 mov dword ptr ds:[0x431750],eax 0042FA98 |. A1 50174300 mov eax,dword ptr ds:[0x431750] 0042FA9D |. 0105 50174300 add dword ptr ds:[0x431750],eax ; 再乘以2存在0x431750 0042FAA3 |. 8D45 FC lea eax,[local.1] 0042FAA6 |. BA ACFB4200 mov edx,Acid_bur.0042FBAC 0042FAAB |. E8 583CFDFF call Acid_bur.00403708 0042FAB0 |. 8D45 F8 lea eax,[local.2] 0042FAB3 |. BA B8FB4200 mov edx,Acid_bur.0042FBB8 0042FAB8 |. E8 4B3CFDFF call Acid_bur.00403708 0042FABD |. FF75 FC push [local.1] ; Acid_bur.0042FBAC 0042FAC0 |. 68 C8FB4200 push Acid_bur.0042FBC8 ; UNICODE “-“ 0042FAC5 |. 8D55 E8 lea edx,[local.6] 0042FAC8 |. A1 50174300 mov eax,dword ptr ds:[0x431750] 0042FACD |. E8 466CFDFF call Acid_bur.00406718 ; 这个call函数中的内容就是生成serial中间数字串的部分（将0x431750的16进制值转化为10进制） 0042FAD2 |. FF75 E8 push [local.6] ; local.6是中间生成的password数字串 0042FAD5 |. 68 C8FB4200 push Acid_bur.0042FBC8 ; UNICODE “-“ 0042FADA |. FF75 F8 push [local.2] ; Acid_bur.0042FBB8 0042FADD |. 8D45 F4 lea eax,[local.3] 0042FAE0 |. BA 05000000 mov edx,0x5 0042FAE5 |. E8 C23EFDFF call Acid_bur.004039AC ; 字符串拼接 0042FAEA |. 8D55 F0 lea edx,[local.4] 0042FAED |. 8B83 E0010000 mov eax,dword ptr ds:[ebx+0x1E0] 0042FAF3 |. E8 60AFFEFF call Acid_bur.0041AA58 ;得到正确的password 0042FAF8 |. 8B55 F0 mov edx,[local.4] ; 输入的Password 0042FAFB |. 8B45 F4 mov eax,[local.3] ; 正确的password 0042FAFE |. E8 F93EFDFF call Acid_bur.004039FC ;两个字符串比较 0042FB03 |. 75 1A jnz short Acid_bur.0042FB1F0x431750的值为00000029十进制为41； 注册机： #include #include using namespace std; int main() { ios::sync_with_stdio(false); string s; int p,l; cout&lt;&lt;”please input name:”; cin&gt;&gt;s; l=s.length(); if(l&lt;4) cout&lt;&lt;”Error!”&lt;&lt;endl; else { p=s[0]; p=p*82; cout&lt;&lt;”Serial:”&lt;&lt;”CW-“&lt;&lt;p&lt;&lt;”-CRACKED”&lt;&lt;endl; } return 0; }]]></content>
      <categories>
        <category>逆向破解</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[XCTF-攻防世界-CRYPTO-新手区 WP]]></title>
    <url>%2F2019%2F07%2F31%2FXCTF-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-CRYPTO-%E6%96%B0%E6%89%8B%E5%8C%BA-WP%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Hexo+GitHub搭建博客以及使用经历]]></title>
    <url>%2F2019%2F07%2F31%2FHexo-GitHub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%BB%8F%E5%8E%86%2F</url>
    <content type="text"><![CDATA[前言历经种种不易，重新又搭了一个博客算是终于可以正常使用，故在此记录一下在搭建博客和使用博客中遇到的一些问题和解决办法。本文参考：https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html 前期工作1.GitHub搭建博客的好处 1.全是静态文件，访问速度快； 2.免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台； 3.可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的； 4.数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行； 5.博客内容可以轻松打包、转移、发布到其它平台； 等等； 当然有人也说用Coding，可以使访问速度提升。 2.准备工作 Github账号 安装node.js、npm 安装git客户端 GitHub搭建博客及相关配置1.在GitHub上搭建仓库新建以用户名为名称的仓库（用户名.github.io） 需要注意几点： 1.每一个github账户最多只能创建一个这样可以直接使用域名访问的仓库。 2.将来博客访问地址就是 www.用户名.github.io 3.仓库创建成功可能需要过一段时间才能生效。 2.绑定域名（可选）绑不绑域名都行，可以直接使用默认的 www.用户名.github.io 来访问。绑定域名可以使博客感觉更个性化一些。对这一块不感兴趣的可以直接跳过。 注册域名的话，推荐阿里、腾讯之类的大公司，安全有保障而且新用户的优惠比较大。 绑定域名分2种情况：带www和不带www的。域名配置最常见有2种方式，CNAME和A记录，CNAME填写域名，A记录填写IP，由于不带www方式只能采用A记录，所以必须先ping一下你的用户名.github.io的IP，然后到你的域名DNS设置页，将A记录指向你ping出来的IP，将CNAME指向你的用户名.github.io，这样可以保证无论是否添加www都可以访问 3.配置SSH keySH key提供了一种与GitHub通信的方式，通过这种方式，能够在不输入密码的情况下，将GitHub作为自己的remote端服务器，进行版本控制。 $ cd ~/ . ssh #检查本机已存在的ssh密钥如果提示：No such file or directory 说明是第一次使用git。 ssh-keygen -t rsa -c &quot;邮箱地址&quot;然后连续3次回车，最终会生成一个文件在用户目录下，打开用户目录，找到.ssh\id_rsa.pub文件，记事本打开并复制里面的内容，打开你的github主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key 将复制的内容粘贴进key里，title填啥都可以，然后保存。 之后需要测试是否成功。 $ ssh -T git@github.com # 注意邮箱地址不用改如果提示：Are you sure you want to continue connecting (yes/no)?输入：yes之后就会看：Hi XXX!You`ve successfully authenticated,but Github does not provide shell access.看到这个信息说明SSH已经配置成功！此时还需要配置： $ git config --global user.name &quot;你的github用户名，非昵称&quot; $ git config --global user.email &quot;填写你的github注册邮箱&quot;hexo与博客配置1.hexoHexo是一个简单、快速、强大的基于 Github Pages 的博客发布工具，支持Markdown格式，有众多优秀插件和主题。官网： http://hexo.iogithub: https://github.com/hexojs/hexo 2.hexo特性由于github pages存放的都是静态文件，博客存放的不只是文章内容，还有文章列表、分类、标签、翻页等动态内容，假如每次写完一篇文章都要手动更新博文目录和相关链接信息，相信谁都会疯掉，所以hexo所做的就是将这些md文件都放在本地，每次写完文章后调用写好的命令来批量完成相关页面的生成，然后再将有改动的页面提交到github。 3.注意事项 开始前先说几点注意事项 1.很多命令既可以用Windows的cmd来完成，也可以使用git bash来完成，但是部分命令会有一些问题，为避免不必要的问题，建议全部使用git bash来执行； 2.hexo不同版本差别比较大，网上很多文章的配置信息都是基于2.x的，所以注意不要被误导； 3.hexo有2种_config.yml文件，一个是根目录下的全局的_config.yml，一个是各个theme下的； 4.安装hexo$ npm install -g hexo5.初始化在电脑的某个地方新建一个名为hexo的文件夹（名字可以随便取，最好不要有中文），由于这个文件夹将来就作为你存放代码的地方，所以最好不要随便放，建议不要放在C盘。 $ cd （hexo文件夹的路径） $ hexo inithexo会自动下载一些文件到这个目录，包括node_modules。 执行 $ hexo g #生成 $ hexo s #启动本地预览 打开浏览器访问 http://localhost:4000 即可看到内容执行完这两条命令后,hexo就会在public文件夹生成相关html文件，这些文件会在之后提交到github。若本地预览加载不出来，一般是因为端口占用的缘故。 6.修改主题第一次初始化的时候hexo已经帮我们写了一篇名为 Hello World 的文章，为了个性化这里我们可以选用自己喜欢的主题替换。在这里可以挑选自己喜欢的主题：https://hexo.io/themes/选好自己喜欢的主题后，每个主题应该都有自己对应的说明和使用方法，这里就不再赘述。 注意事项： 1.修改完主题需要执行 ‘hexo g’ 来重新生成 2.如果遇到奇怪的问题，可以先执行 hexo clean 来清理一下public的内容，然后再重新生成和预览。 7.上传前的注意事项因为从hexo提交代码时会把你以前的所有代码都删掉，所以在上传代码到github之前，一定要记得先把你以前所有代码下载下来（虽然github有版本管理，但备份一下总是好的）。 8.上传到github首先，确定SSH key是配置好的其次，还需要安装一个插件： npm install hexo-deployer-git --save然后配置_config.yml中有关deploy的部分： deploy: type: git repository: git@github.com:liuxianan/liuxianan.github.io.git branch: master然后用git bash，输入 hexo d就会将本次有改动的代码全部提交，没有改动的不会。 9.保留CNAME、README.md等文件提交之后会发现以前其它代码都没了，此时不要慌，一些非md文件可以把他们放到source文件夹下，这里的所有文件都会原样复制（除了md文件）到public目录的。由于hexo默认会把所有md文件都转换成html，包括README.md，所有需要每次生成之后、上传之前，手动将README.md复制到public目录，并删除README.html。 10.特别注意事项_config.yml里面都是一些全局配置，这里就不作详细介绍了。需要特别注意的地方是，冒号后面必须有一个空格，否则可能会出问题！！！ 写博客写博客的工具写博客的工具和插件都挺多的，之前还试了很多，大家也可以去找一找，有一些还是挺好用的。我自己用的是Visual Studio Code。 写博客到hexo根目录下，执行： hexo new &apos;文章名&apos;hexo会在_posts下生成相关md文件只需要打开这个文件就可以写内容了一般完整格式如下： — title: postName #文章页面上的显示名称，一般是中文 date: 2013-12-02 15:30:16 #文章生成时间，一般不改，当然也可以任意修改 categories: 默认分类 #分类 tags: [tag1,tag2,tag3] #文章标签，可空，多标签请用格式，注意:后面有个空格 description: 附加一段文章摘要，字数最好在140字以内，会出现在meta的description里面 — 以下是正文具体的Markdown语句可以参考你选择的主题的说明。 写完以后只要执行 ‘hexo d’ 就可以了。]]></content>
  </entry>
  <entry>
    <title><![CDATA[逆向破解——写在开头]]></title>
    <url>%2F2019%2F07%2F30%2F%E9%80%86%E5%90%91%E7%A0%B4%E8%A7%A3%E2%80%94%E2%80%94%E5%86%99%E5%9C%A8%E5%BC%80%E5%A4%B4%2F</url>
    <content type="text"><![CDATA[前言入坑逆向有一段时间了，主要是看资料和打CTF，准备之后整理总结一下以前写过的逆向相关的东西发布到博客上，之后学习到的知识也会整理好发布出来，算是自己学习的记录吧。之后主要是一些160个CrackMe相关的记录，所以在这先简单说一下CrackMe相关的知识。 什么是CrackMeCrackMe都是一些公开给别人尝试破解的小程序，制作 crackme 的人可能是程序员，想测试一下自己的软件保护技术，也可能是一位 cracker，想挑战一下其它 cracker 的破解实力，也可能是一些正在学习破解的人，自己编一些小程序给自己破。 ①、KeyGenMe是要求别人做出它的 keygen (序号产生器) ②、ReverseMe 要求别人把它的算法做出逆向分析 ③、UnpackMe 是要求别人把它成功脱壳]]></content>
      <categories>
        <category>逆向破解</category>
      </categories>
  </entry>
</search>
